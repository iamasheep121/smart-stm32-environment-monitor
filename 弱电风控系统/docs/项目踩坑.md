### 1.气体检测踩坑

void GetBothMQ_Average(uint16_t* mq2_avg, uint16_t* mq7_avg)
{
    uint16_t sum_mq2 = 0, sum_mq7 = 0;

```c
for(uint16_t i = 0; i < 50; i++)
{
    uint16_t* adc_values = ADC_Get_Values();
    sum_mq2 += adc_values[0];  // MQ2
    sum_mq7 += adc_values[1];  // MQ7

    Delay_ms(2);
}

*mq2_avg = sum_mq2 / 50;
*mq7_avg = sum_mq7 / 50;
```

* 这个是我为**mq2**和**mq7**写的**均值滤波函数**，在自动模式测试中发现。

* **解决办法**：由于这两个气体传感器的功能相当于是**气体检测开关**，根本不可能达到像SHT30那样的精度，所以对其进行滤波完全没必要，还会造成气体检测迟钝，因为adc转换也是需要时间的。

* **问题描述**：如下图，两个气体值不会发生变化

![](C:\Users\86184\AppData\Roaming\marktext\images\2025-11-01-00-09-02-image.png)

**效果**：去掉滤波函数后反应灵敏

* 总结：不要为了技术去把简单的东西复杂化，我之前还想着把这个电压值线性转换为**ppm**，后面发现也不实用，毕竟模块性能就摆在这里

### 2. 重复报警问题

**问题描述：**  
传感器超过阈值时，系统持续重复发送报警信息

**现象：**

温度报警! 当前:32.1C, 阈值:30C
温度报警! 当前:32.1C, 阈值:30C  // 每5ms重复一次
温度报警! 当前:32.1C, 阈值:30C
串口被刷屏，重要信息被淹没

**解决方案：**

```c
typedef struct {
    uint8_t temp_alarm;
    uint8_t mq2_alarm; 
    uint8_t mq7_alarm;
    uint8_t fan_auto_status;
} AutoControl_t;

AutoControl_t AutoControl = {0, 0, 0, 0};

// 自动控制函数
void AutoControl_Handler(SystemState_t *state, AutoControl_t *auto_ctrl)
{
    // 温度报警检测(利用标志位防止重复报警)
    if(state->current_temp > state->temp_threshold) {
        if(!auto_ctrl->temp_alarm) {
            UsartPrintf(USART1, "温度报警! 当前:%.1fC, 阈值:%dC\r\n", 
            state->current_temp, state->temp_threshold);
            auto_ctrl->temp_alarm = 1;
        }
    } else {
        auto_ctrl->temp_alarm = 0;
    }
}
```

**效果：**

- 报警信息减少 95%

- 系统日志清晰可读

### 3.按键不灵敏

**问题描述**：按键无反应，反应迟钝

**现象**：用串口调试助手打印控制按键IO口，发现一直为**高电平**

**解决方案**：在常规工程中，一般都是单片机io口和电源负极相连，设置为高电平，当按键按下为低电平。但是由于此按键太小，我把另一端接在高电平上，导致按下或者不按下都是高电平。查资料得出，可以改程序，有两个缺点，一个是有微小电流流过，另一个是抗干扰能力较差。我将GPIO_MODE设置为下拉模式，改一下函数按下逻辑

- 按键不灵敏是由于消抖时间过长，要么增加主函数扫描频率，要么减少消抖时长

**效果**：问题解决，按键基本可用

### 4.电平毛刺过大

**问题描述**：尽管使用稳压模块，在电机启动时仍然出现电源波形毛刺过长，如下图

![](C:\Users\86184\AppData\Roaming\marktext\images\2025-11-01-00-42-09-9164c4e7199849414e984d1ebb8750e1.jpg)

**解决方案**：上网查并联一个104陶瓷电容，如下图

![](C:\Users\86184\AppData\Roaming\marktext\images\2025-11-01-00-42-28-d95d2181a7ab938f27609eefad88e3f6.jpg)

**效果**：毛刺减少

### 5.魔法数字和函数过长

* **问题描述：** 在主函数开发过程中发现函数超过**50行**，有很多**if-else**，层层嵌套，不利于后续开发和维护，改一个地方其他地方也要改。

* **现象**:如下所示，

```c
   if(key)
    {
        switch(key)
        {
            case KEY_MODE:
                UsartPrintf(USART1, "模式键按下\r\n");
                // 循环切换工作模式
                CurrentMode.current_mode = (CurrentMode.current_mode + 1) % SYS_MODE_COUNT;
                UsartPrintf(USART1, "切换到: %s\r\n", GetModeString(CurrentMode.current_mode));

                // 如果是设置模式，显示设置界面
                if(CurrentMode.current_mode == SYS_SETTING_MODE)
                {
                    PrintSettingStatus(&CurrentMode);
                }
                break;

            case KEY_UP:
                UsartPrintf(USART1, "上调键按下\r\n");
                if(CurrentMode.current_mode == SYS_MANUAL_MODE)
                {
                    // 手动模式：调节电机速度
                    if(CurrentMode.motor_speed < 100)
                    {
                        CurrentMode.motor_speed += 5;

                        UsartPrintf(USART1, "电机速度: %d%%\r\n", CurrentMode.motor_speed);
                        Motor_Speed(CurrentMode.motor_speed);
                    }
                }
                else if(CurrentMode.current_mode == SYS_SETTING_MODE)
                {
                    // 设置模式：增加当前设置项目的值
                    switch(CurrentMode.current_setting)
                    {
                        case SET_TEMP_THRESHOLD:
                            if(CurrentMode.temp_threshold < 50)
                                CurrentMode.temp_threshold += 1;
                            break;
                        case SET_HUMIDITY_THRESHOLD:
                            if(CurrentMode.humidity_threshold < 95)
                                CurrentMode.humidity_threshold += 5;
                            break;
                        case SET_MQ2_THRESHOLD:
                            if(CurrentMode.mq2_threshold < 1000)
                                CurrentMode.mq2_threshold += 10;
                            break;
                        case SET_MQ7_THRESHOLD:
                            if(CurrentMode.mq7_threshold < 1000)
                                CurrentMode.mq7_threshold += 10;
                            break;
                    }
                    PrintSettingStatus(&CurrentMode);
                }
                break;

            case KEY_DOWN:
                UsartPrintf(USART1, "下调键按下\r\n");
                if(CurrentMode.current_mode == SYS_MANUAL_MODE)
                {
                    // 手动模式：调节电机速度
                    if(CurrentMode.motor_speed > 0)
                    {
                        CurrentMode.motor_speed -= 5;
                        UsartPrintf(USART1, "电机速度: %d%%\r\n", CurrentMode.motor_speed);
                        Motor_Speed(CurrentMode.motor_speed);
                    }
                }
                else if(CurrentMode.current_mode == SYS_SETTING_MODE)
                {
                    // 设置模式：减少当前设置项目的值
                    switch(CurrentMode.current_setting)
                    {
                        case SET_TEMP_THRESHOLD:
                            if(CurrentMode.temp_threshold > 10)
                                CurrentMode.temp_threshold -= 1;
                            break;
                        case SET_HUMIDITY_THRESHOLD:
                            if(CurrentMode.humidity_threshold > 30)
                                CurrentMode.humidity_threshold -= 5;
                            break;
                        case SET_MQ2_THRESHOLD:
                            if(CurrentMode.mq2_threshold > 100)
                                CurrentMode.mq2_threshold -= 10;
                            break;
                        case SET_MQ7_THRESHOLD:
                            if(CurrentMode.mq7_threshold > 50)
                                CurrentMode.mq7_threshold -= 10;
                            break;
                    }
                    PrintSettingStatus(&CurrentMode);
                }
                break;

            case KEY_CONFIRM:
                UsartPrintf(USART1, "确认键按下\r\n");
                if(CurrentMode.current_mode == SYS_SETTING_MODE)
                {
                    // 设置模式下：切换设置项目
                    CurrentMode.current_setting = (CurrentMode.current_setting + 1) % SET_ITEM_COUNT;
                    UsartPrintf(USART1, "切换到设置项目: %s\r\n", GetSettingString(CurrentMode.current_setting));
                    PrintSettingStatus(&CurrentMode);
                }
                else
                {
                    // 其他模式下：显示系统状态
                    PrintSystemStatus(&CurrentMode);
                }
                break;
```

* **解决办法**：思路是将四个按键的处理过程封装为**四个函数**，每个按键按下时执行对应任务，每个任务要修改时只需要**更改单独函数**，而且更好**测试**。魔法数字是我在网上查阅的知，这种直接赋值的操作应该避免，用宏定义代替，避免三月以后自己不认识的情况还有要修改需求时一个个手动改数字，漏一个就出bug。

* **效果**：完美移植成功，我新建了**Key_Handler.c**和**Key_Handler.h**文件，把相关逻辑放进去，请看图片,怎么样，是不是很清晰，原来的一个函数变成6个函数，不仅模块化，而且更加解耦，测试也方便

```c
    while(1)
    {
        /* 键码获取*/
        uint8_t key = KEY_Scan();
        /* 传感器数据获取*/
        mq_values = Sensors_ReadAndPrint();
        if(SHT30_ReadData(&CurrentMode.current_temp, &CurrentMode.current_humidity) == 0) 
        {
            //这里还没想好，得到数据正确应该什么都不做，错误才有反馈
        }
        else{ UsartPrintf(USART1, "温湿度获取错误\r\n");}
        CurrentMode.current_mq2 = mq_values.mq2_value;
        CurrentMode.current_mq7 = mq_values.mq7_value;

        if(key){KEY_HandleKeyEvent(key,&CurrentMode);}

         //自动模式下控制函数
         AutoControl_Handler(&CurrentMode, &AutoControl);
         /* OLED 显示数据精简版*/
         OLED_Display_Simple(&CurrentMode);

         Delay_ms(5);
    }

}
```

### 6.连接云平台

* **问题描述**：配置好三元组后使用算法生成动态**token**连接**onenet**云平台，**OneNet_DevLink**函数使用时一直卡死。

* **现象**：

```c
OLED_ShowString(20,24,"Networking",OLED_6X8);
 ESP8266_Init(); //初始化ESP8266
 OLED_ShowString(0,24," ",OLED_6X8);
 OLED_ShowString(0,24," Connected to",OLED_6X8);
 OLED_ShowString(30,48,"ONENET",OLED_6X8);
 UsartPrintf(USART_DEBUG, "Connect MQTTs Server...\r\n");
 while(ESP8266_SendCmd(ESP8266_ONENET_INFO, "CONNECT"))
 Delay_ms(500);
 UsartPrintf(USART_DEBUG, "NET_OK\r\n");
```

卡在这个地方

```c
while(OneNet_DevLink()) //接入OneNET
 Delay_ms(500);
```

* **解决办法**：

1.使用mqttfx软件，手动生成token测试发布订阅onenet，看看能不能连通。发现可以连接。

2.网上找类似连接程序源码，将自己的三元组换上去，发现可以连接。那就说明我的生成没有问题。对了，其中还有个小插曲，我开通两个产品，一个用数据流，一个用onejson，后面才发现不一样。

3.网上查找说可能是堆栈设置太小，导致堵塞，堆栈设置为**0x1000**和**0x800**后问题解决。

小技巧：发现可以点击书签实现不同文件之间的快速跳转。

### 7.云平台下发指令后设备自动离线

**问题描述**：云平台下发指令后掉线

**解决办法**：发送指令后没有释放内存。每次104kb造成内存泄漏，然后系统崩溃，主要是一个指令解析后没有进行json释放

### 8.上电后串口和烧录器会识别不出来（偶尔）

**问题描述**：电脑显示未知设备

**解决办法**：换拓展坞口后就可以正常串口调试以及程序烧录

### 9.单片机发送消息onenet平台不更新

**问题描述**：

单片机向onenet云平台发送传感器数据，发现都不更新

**解决办法**：

发现标识符有两个下错了，而且就算有一个写错平台也不更新。其二，经过mqttfx测试得知。元素精度是浮点型，但是平台只接受一位小数，**浮点型数据超过一位小数不更新数据**

### 10.风扇转起来就不停了

**问题描述**: 自动模式切换到其他模式时风机速度不会重置

**解决办法**：没有更新风扇状态，目前只能通过切换模式打断风机状态，比如自动切换到其他模式

### 11.OLED平台模式下不显示

**问题描述**：切换到平台模式OLED不显示数据

**解决办法**：进入平台模式没有clearOLED，字体像素位置也不对

### 12.网络和本地初始化错误

**问题描述**：一但wifi模块断开，就一直卡在网络初始化，本地的数据不能显示

现象：OLED显示网络连接中，串口调试显示重连发送三元组

**解决办法**：将两者分开，先初始化硬件，让本地程序运行正常，如果网络正常就正常联网，不正常则只显示本地数据且提示网络错误。

细分网络状态，将网络故障细分为有网和没网，有网就在线，没网就离线

### 13.pcb孔小

**问题描述**：孔设计为0.7mm，太小，模块引脚插不进去

**解决办法**:排座的引脚可以焊接进去，不用重新设计

### 14.调试显示屏，不同的显示屏大小不一样

**问题描述**：我这块是0.96寸的，128X64的，以后换显示屏肯定又得调，有没有什么办法能适配其他显示屏呢，难道是换一个显示屏调一次，或者是提前写好常见显示屏驱动？

**解决办法**：以后做项目提前写可能用到的屏幕尺寸

### 15.平台下发指令，但是蜂鸣器响一下就不响了

**问题描述**：蜂鸣器响了，但是在自动模式下会被电机报警自动控制算法打断，如果当前的环境优良，不会响

**解决办法**：这个不算bug，其他模式都可以正常工作，自动模式本来就是自动控制

### 16.这个传感器数据读取会阻塞程序100ms

**问题描述**：传感器ad转换需要时间，会阻塞函数

```c
MQ_Values_t Sensors_ReadAndPrint(void) {
 Delay_ms(100);
```

```c
uint16_t* adc_values = ADC_Get_Values();

MQ_Values_t result;
result.mq2_value = (adc_values[0] * 100) / 4095; // 0-100%
result.mq7_value = (adc_values[1] * 100) / 4095; // 0-100%

return result;
```

}

**解决办法**：暂时未解决，以后学了rtos再改进

### 17.焊接板子后发现引脚和面包板上的不对应

**问题描述**：我原来的oled电源是从stlink上取电，导致我电路原理图画错，对应的io口变成电源输入口

**解决办法**：飞线从电源入口取电

### 18.按键按下没有反应

**问题描述**：四个按键都没反应

**解决办法**：发现是以前残留问题，以前是按下高电平，现在正好改过来。改为按下低电平，将io口设置为上拉，按下读取函数设置为0

```c
#define KEY_MODE_PRES (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_12) == 0)
#define KEY_UP_PRES (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_13) == 0)
#define KEY_DOWN_PRES (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_14) == 0)
#define KEY_CONFIRM_PRES (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_15) == 0)
```

### 19.温度湿度不正常

**问题描述**：oled显示温度-45，湿度0

**解决办法**：以前因为物理空间太小原因，连接oled 的iic线没办法连接sht30，重新开了两个io口作为连接的sda和scl，现在改一下驱动引脚配置就可以了。
